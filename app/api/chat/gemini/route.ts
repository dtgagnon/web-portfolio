import { NextRequest, NextResponse } from 'next/server';
import { MessageRepository, SessionRepository, UserRepository } from '@/lib/database';
import { VertexAI, HarmCategory, HarmBlockThreshold, Part, Content } from '@google-cloud/vertexai';
import { randomUUID } from 'crypto';

// This type will be updated for Gemini, e.g., using sessionId
type StreamEvent = 
  | { type: 'content'; content: string; sessionId: string } 
  | { type: 'complete'; sessionId: string; content?: string }
  | { type: 'error'; content: string };

interface ChatRequest {
  message: string;
  sessionId?: string; // Will be used as the primary identifier for Gemini
}

import { getModel } from '@/lib/api/llm/gemini';

// Get the Gemini model with system instructions securely applied
const geminiModel = getModel('gemini-2.5-flash-preview-05-20');

// POST /api/chat/gemini - Send a message and get a streaming response using Gemini
export async function POST(request: NextRequest) {
  console.log('Gemini POST handler invoked');
  try {
    const requestData = await request.json();
    console.log('Received request data:', JSON.stringify(requestData));
    
    const { message, sessionId: incomingSessionId, userId } = requestData;
    
    // Initialize sessionId variable to be used throughout the function
    let sessionId = incomingSessionId;
    
    if (!message) {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 });
    }

    console.log('userId after destructuring:', userId, 'type:', typeof userId);
    
    // More robust userId validation
    if (userId === undefined || userId === null) {
      return NextResponse.json({ 
        error: 'userId is required', 
        details: 'userId was not found in the request body' 
      }, { status: 400 });
    }
    
    // Convert userId to string if it's not already (just to be safe)
    const userIdStr = String(userId);
    
    // Make sure it's not empty
    if (!userIdStr.trim()) {
      return NextResponse.json({ 
        error: 'userId cannot be empty', 
        details: 'A non-empty userId value is required' 
      }, { status: 400 });
    }

    // Synchronous user and session handling to fix scope issues
    async function setupUserAndSession() {
      // Handle session ID management
      let finalSessionId = incomingSessionId;
      let finalUserId: string;
      
      try {
        console.log('Original userId from client:', userId);
        
        // First try to find if this user already exists in our database
        let user = await UserRepository.findById(userId);
        
        if (user) {
          console.log('Found existing user with client-provided ID:', user.id);
        } else {
          // If user with client ID doesn't exist, check by a deterministic email
          const userEmail = `chat-user-${userId}@chat.example.com`;
          const userName = `Chat User ${String(userId).substring(0, 6)}`;
          
          user = await UserRepository.findByEmail(userEmail);
          
          if (!user) {
            // No user exists either by ID or email, so create one (with UUID generated by repository)
            console.log('Creating new user with email:', userEmail, 'for client ID:', userId);
            try {
              user = await UserRepository.create(userEmail, userName);
              console.log('User created successfully with database ID:', user.id);
            } catch (userCreateError) {
              console.error('Failed to create user:', userCreateError);
              throw new Error(`Failed to create user record: ${userCreateError}`);
            }
          } else {
            console.log('Found existing user by email with database ID:', user.id);
          }
        }
        
        // Set the database user ID
        finalUserId = user.id;
        
        // With user established, now handle session
        if (!finalSessionId) {
          // If no sessionId provided, create a new session and get its ID
          try {
            const newSession = await SessionRepository.create(finalUserId);
            finalSessionId = newSession.id;
            console.log('Created new session:', finalSessionId, 'with user ID:', finalUserId);
          } catch (error) {
            console.error('Error creating session:', error);
            throw new Error(`Failed to create chat session: ${error}`);
          }
        } else {
          // If sessionId provided, ensure it exists or create it
          const existingSession = await SessionRepository.findById(finalSessionId);
          if (!existingSession) {
            try {
              // Create a new session with the properly created user ID
              const newSession = await SessionRepository.create(finalUserId);
              finalSessionId = newSession.id;
              console.log('Created replacement session:', finalSessionId, 'with user ID:', finalUserId);
            } catch (error) {
              console.error('Session creation failed, trying to proceed:', error);
              throw new Error(`Failed to create replacement session: ${error}`);
            }
          } else {
            console.log('Using existing session:', finalSessionId);
          }
        }
        
        // All successful, now save the user message
        console.log('Saving user message with database user ID:', finalUserId);
        await MessageRepository.create({
          session_id: finalSessionId,
          user_id: finalUserId, // Use the database user ID 
          role: 'user',
          content: message,
        });
        
        return { sessionId: finalSessionId, userId: finalUserId };
      } catch (error) {
        console.error('Error in user/session handling:', error);
        throw error;
      }
    }
    
    // Run the setup and continue with the rest of the processing
    let userSessionInfo;
    let databaseUserId: string;
    try {
      console.log('Starting user and session setup...');
      userSessionInfo = await setupUserAndSession();
      sessionId = userSessionInfo.sessionId;
      databaseUserId = userSessionInfo.userId;
      console.log('Setup completed successfully - using sessionId:', sessionId, 'and databaseUserId:', databaseUserId);
    } catch (error) {
      console.error('Failed in user/session setup phase:', error);
      return NextResponse.json({ 
        error: 'Failed to process user or session', 
        details: String(error) 
      }, { status: 500 });
    }

    // 2. Fetch conversation history from DB
    const dbHistory = await MessageRepository.findBySessionId(sessionId);

    // Format history for Gemini: Array of Content objects
    // Ensure dbHistory messages have content and map roles correctly
    const geminiHistory: Content[] = dbHistory
      .filter(msg => msg.content) // Ensure message content exists
      .map(msg => ({
        role: msg.role === 'user' ? 'user' : 'model', // Gemini: 'user' or 'model'
        parts: [{ text: msg.content }],
      }));

    // 3. Prepare the request for Gemini, adding current user message to history
    const currentMessageContent: Content = { role: 'user', parts: [{ text: message }] };
    const reqContents: Content[] = [...geminiHistory, currentMessageContent];

    const req = { contents: reqContents };

    // 4. Call Gemini API and get the stream
    const streamingResp = await geminiModel.generateContentStream(req);

    // 5. Process the stream and send to client
    const encoder = new TextEncoder();
    let accumulatedResponseText = '';

    const readableStream = new ReadableStream({
      async start(controller) {
        try {
          for await (const item of streamingResp.stream) {
            if (item.candidates && item.candidates[0].content && item.candidates[0].content.parts) {
              for (const part of item.candidates[0].content.parts) {
                if (part.text) {
                  accumulatedResponseText += part.text;
                  const streamEvent: StreamEvent = {
                    type: 'content',
                    content: part.text,
                    sessionId: sessionId,
                  };
                  controller.enqueue(encoder.encode(`data: ${JSON.stringify(streamEvent)}\n\n`));
                }
              }
            }
          }

          // After stream finishes, save the full model response
          if (accumulatedResponseText) {
            await MessageRepository.create({
              session_id: sessionId,
              user_id: databaseUserId, // Use the database user ID, not the client ID
              role: 'assistant',
              content: accumulatedResponseText,
            });
          }

          // Send completion event
          const completeEvent: StreamEvent = {
            type: 'complete',
            sessionId: sessionId,
            content: accumulatedResponseText,
          };
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(completeEvent)}\n\n`));
        } catch (error) {
          console.error('Error during Gemini stream processing:', error);
          const errorEvent: StreamEvent = {
            type: 'error',
            content: 'Error processing stream: ' + (error instanceof Error ? error.message : String(error)),
          };
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(errorEvent)}\n\n`));
        } finally {
          controller.close();
        }
      },
    });

    return new Response(readableStream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
      },
    });

  } catch (error) {
    console.error('Gemini POST error:', error);
    return NextResponse.json({ 
      error: 'Failed to process Gemini message',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

// GET /api/chat/gemini - Get chat history for a session
export async function GET(request: NextRequest) {
  console.log('Gemini GET handler invoked');
  try {
    const sessionId = request.nextUrl.searchParams.get('sessionId');

    if (!sessionId) {
      return NextResponse.json({ error: 'Session ID is required' }, { status: 400 });
    }

    // --- Start of Gemini specific logic to be implemented ---
    // 1. Fetch messages from database using MessageRepository.findBySessionId(sessionId)
    // 2. Format them as needed for the client
    // --- End of Gemini specific logic ---

    // Placeholder response
    const messages = await MessageRepository.findBySessionId(sessionId);
    return NextResponse.json(messages);

  } catch (error) {
    console.error('Gemini GET error:', error);
    return NextResponse.json({ 
      error: 'Failed to fetch Gemini chat history',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

// DELETE /api/chat/gemini - Delete a chat session
export async function DELETE(request: NextRequest) {
  console.log('Gemini DELETE handler invoked');
  try {
    const { sessionId } = await request.json();

    if (!sessionId) {
      return NextResponse.json({ error: 'Session ID is required' }, { status: 400 });
    }

    // --- Start of Gemini specific logic to be implemented ---
    // 1. Delete session and associated messages from database using SessionRepository.delete and MessageRepository.deleteBySessionId
    // --- End of Gemini specific logic ---
    
    // Placeholder action
    await MessageRepository.deleteBySessionId(sessionId);
    await SessionRepository.delete(sessionId);

    return NextResponse.json({ message: `Chat session ${sessionId} deleted successfully (Gemini)` });

  } catch (error) {
    console.error('Gemini DELETE error:', error);
    return NextResponse.json({ 
      error: 'Failed to delete Gemini chat session',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}
